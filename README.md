# bootloader-trusting-trust
CS 140E final project

For our final project, we made two main things: a software bootloader uploader and an evil bootloader. For the software bootloader uploader, we edit the fat32 filesystem to overwrite our kernel.img. This feature works through the file boot-splicing.py which takes a kernel image and makes a bin file that when run will upload that bootloader. For our evil bootloader, we take advantage of VM to trap every UART access by the user and save all the characters they write to a buffer in unused space. Then, it detects when the program is ending and prints out the messages it detected and runs an arbitrary program (currently blinks a light). In the future, we want to make it so that all of this cleanup code that happens on reboot is controlled over NRF by the pi. We made some code for this (in NRF and bootloader-sw-upload folders there are files that read the filesystem from one pi and transmits to the other), but we had issues where staff spi would fail when we ran it at high memory addresses. This is definitely something we want to come back to though since this would allow us to specify programs to run at runtime as well as recieve information remotely without the user recieving any indication that their pi is infected.
